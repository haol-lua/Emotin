<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>루아의 감정테스트 & 명언💙</title>
  <link href="https://fonts.googleapis.com/css2?family=Gowun+Batang:wght@400;700&display=swap" rel="stylesheet">

  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center; /* 수직 중앙 정렬 유지 */
      min-height: 100vh;
      margin: 0;
      padding: 20px;
      /* 글꼴 변경 */
      font-family: 'Gowun Batang', serif;
      /* 배경색 조정: 눈이 편하고 따뜻한 느낌의 색상 */
      background-color: #fff0e0; /* 부드러운 복숭아/베이지 톤 유지 */
      color: #333; /* 기본 텍스트 색상 */
      box-sizing: border-box;
      padding-bottom: 80px; /* 고정 버튼 영역만큼 하단 패딩 추가 */
      overflow-y: auto; /* 스크롤 가능하도록 설정 */
    }

    /* Text elements that will fade */
    .fade-element {
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
      text-align: center;
      margin-bottom: 20px;
      width: 100%;
      max-width: 600px;
    }

    /* Class to make elements visible */
    .fade-element.visible {
      opacity: 1;
    }

    h1 {
      font-size: 1.8em;
      color: #5a3e36; /* 제목 색상 조정 */
      margin-bottom: 30px; /* 제목과 내용 간격 추가 */
      font-weight: bold; /* 질문 텍스트 굵기 (기본 h1보다 명시적으로) */
    }

    p {
        font-size: 1.1em;
        line-height: 1.6;
    }

    /* 버튼 컨테이너 - 위치 고정 */
    .buttons {
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s ease-in-out 0.3s;
      width: 100%;
      /* 위치 고정 */
      position: fixed;
      bottom: 0; /* 하단에 고정 */
      left: 0;
      width: 100%; /* 너비 전체 */
      background-color: #fff0e0; /* 배경색과 동일하게 설정 */
      padding: 10px 20px; /* 패딩 추가 */
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1); /* 상단 그림자 */
      box-sizing: border-box; /* 패딩 포함 */
      z-index: 1000;
       /* JS에서 display 제어 */
      display: none; /* Initially hidden by default */
    }


    .buttons.visible {
        opacity: 1;
    }

    button {
      margin: 8px; /* 버튼 간 기본 마진 */
      padding: 12px 25px;
      font-size: 1em;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      /* 버튼 색상 조정: 배경색과 어울리도록 */
      background-color: #ff914d; /* 따뜻한 오렌지 톤 */
      color: white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s ease, transform 0.1s ease;
    }

    button:hover {
      background-color: #357abd; /* 호버 시 약간 어둡게 */
    }

    button:active {
        transform: scale(0.98);
    }

    /* 새로운 첫 화면 스타일 */
    #initial-page {
        display: flex; /* JS에서 제어 */
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        min-height: calc(100vh - 80px); /* 버튼 영역 제외 높이 */
        box-sizing: border-box;
        opacity: 0; /* JS에서 제어 */
        transition: opacity 0.5s ease-in-out;
         /* Initially hidden by default */
        display: none;
    }

    #initial-page.visible {
        opacity: 1;
    }

    #initial-page h1 {
        margin-bottom: 10px;
    }

    #initial-page .buttons {
        position: static; /* 첫 화면 버튼은 고정 해제 */
        box-shadow: none;
        background-color: transparent;
        padding: 0;
        margin-top: 20px;
        opacity: 0; /* JS에서 별도로 페이드인 제어 */
        transition: opacity 0.5s ease-in-out 0.5s; /* 텍스트 페이드인 후 지연 */
         /* JS에서 display 제어 */
        display: none; /* Initially hidden by default */
    }

    #initial-page .buttons.visible {
        opacity: 1;
    }


    /* 감정 테스트 관련 요소들 (초기 숨김) */
    #emotion-test-area {
        display: none; /* JS에서 제어 */
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        max-width: 600px;
        min-height: calc(100vh - 80px); /* 버튼 영역 제외 높이 */
        box-sizing: border-box;
        opacity: 0; /* JS에서 제어 */
        transition: opacity 0.5s ease-in-out;
         /* Initially hidden by default */
        display: none;
    }

    #emotion-test-area.visible {
         opacity: 1;
    }

    #emotion-test-area > .fade-element {
        /* 감정 테스트 내부 요소들의 페이드인/아웃 */
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
    }

     #emotion-test-area > .fade-element.visible {
         opacity: 1;
     }


    #emotion-test-area #emotion-choice h1 {
        margin-bottom: 10px;
    }

    #emotion-test-area #emotion-choice .buttons button {
        margin: 10px;
        background-color: #ffc107; /* 감정 선택 버튼 색상 */
    }
    #emotion-test-area #emotion-choice .buttons button:hover {
        background-color: #ffb300;
    }


    /* 결과 텍스트 영역 스타일 */
    #emotion-test-area #result {
      font-size: 1.3em;
      color: #333;
      margin-top: 20px;
      text-align: center;
      max-width: 600px;
      line-height: 1.6;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
      margin-bottom: 80px; /* 결과 텍스트 하단에도 고정 버튼 영역만큼 패딩 추가 */
    }

    #emotion-test-area #result.visible {
        opacity: 1;
    }

    #emotion-test-area #result .result-text-area {
        min-height: 150px;
        text-align: left;
        padding: 0;
        border: none;
        border-radius: 0;
        background-color: transparent;
        box-shadow: none;
        /* 페이지네이션 전환 애니메이션 - opacity 전환 시간 조정 */
        transition: opacity 1.5s ease-in-out; /* 이전 0.3s에서 1.5s로 증가 */
    }

     #emotion-test-area #result .result-text-area p {
         margin-bottom: 10px;
         font-weight: 500; /* 일반 텍스트 굵기 조정 (질문 텍스트와 유사하게) */
     }

     #emotion-test-area #result .result-text-area strong {
         display: block;
         margin-bottom: 5px;
         color: #7a5b50; /* 제목 부분 색상 조정 */
         font-weight: bold; /* strong 태그는 더 진하게 */
     }

     #emotion-test-area #result .result-text-area hr {
         margin: 20px 0;
         border: 0;
         border-top: 1px solid #e0d0c0; /* 구분선 색상 조정 */
     }


    /* 감정 테스트 버튼 컨테이너 (질문/결과) */
    #emotion-test-area .buttons {
        position: fixed; /* 감정 테스트 중 버튼은 고정 */
        bottom: 0;
        left: 0;
        width: 100%;
        background-color: #fff0e0;
        padding: 10px 20px;
        box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1);
        box-sizing: border-box;
        z-index: 1000;
        display: flex; /* JS에서 제어 */
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        opacity: 0; /* JS에서 제어 */
        transition: opacity 0.5s ease-in-out;
         /* Initially hidden by default */
        display: none;
    }

    #emotion-test-area .buttons.visible {
        opacity: 1;
    }


    /* 페이지네이션 버튼 컨테이너 */
    .pagination-buttons {
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
        display: flex; /* JS에서 제어 */
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        /* 위치 고정 */
        position: fixed;
        bottom: 0; /* 하단에 고정 */
        left: 0;
        width: 100%; /* 너비 전체 */
        background-color: #fff0e0; /* 배경색과 동일하게 설정 */
        padding: 10px 20px; /* 패딩 추가 */
        box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1); /* 상단 그림자 */
        box-sizing: border-box; /* 패딩 포함 */
        z-index: 1000;
         /* Initially hidden by default */
        display: none;
    }

    .pagination-buttons.visible {
        opacity: 1;
    }

    .pagination-buttons button {
        margin: 5px 8px;
    }


    /* 명언 페이지 관련 요소들 (초기 숨김) */
    #quote-page {
        display: none; /* JS에서 제어 */
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        max-width: 600px;
         min-height: calc(100vh - 80px); /* 버튼 영역 제외 높이 */
        box-sizing: border-box;
        text-align: center;
        opacity: 0; /* JS에서 제어 */
        transition: opacity 0.5s ease-in-out;
         /* Initially hidden by default */
        display: none;
    }

    #quote-page.visible {
        opacity: 1;
    }

    #quote-page h1 {
        margin-bottom: 30px;
    }

    #quote-display {
        font-size: 1.4em;
        line-height: 1.8;
        min-height: 150px; /* 명언이 표시될 최소 높이 */
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        margin-bottom: 30px;
        padding: 20px;
        /* 박스 스타일 제거 */
        /* border: 1px solid #e0d0c0; */
        /* border-radius: 10px; */
        /* background-color: #ffffff; */
        /* box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05); */
        width: 100%;
        box-sizing: border-box;
        overflow: hidden; /* 슬롯 애니메이션 시 내용 넘침 방지 */
        position: relative; /* 애니메이션을 위한 기준점 */
         /* 슬롯 애니메이션을 위한 CSS */
        opacity: 1; /* 초기 opacity 설정 */
        transition: opacity 0.1s ease-in-out; /* 빠른 전환 */
    }

    /* 슬롯 애니메이션 효과를 위한 클래스 */
    .slot-animating {
        /* 애니메이션 중일 때 적용될 스타일 */
        /* JS에서 opacity를 빠르게 변경하며 애니메이션 구현 */
    }


    /* 명언 페이지 하단 버튼 컨테이너 */
    #quote-page .buttons {
         position: fixed; /* 명언 페이지 중 버튼은 고정 */
         bottom: 0;
         left: 0;
         width: 100%;
         background-color: #fff0e0;
         padding: 10px 20px;
         box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1);
         box-sizing: border-box;
         z-index: 1000;
         display: flex; /* JS에서 제어 */
         justify-content: center;
         align-items: center;
         flex-wrap: wrap;
         opacity: 0; /* JS에서 제어 */
         transition: opacity 0.5s ease-in-out;
          /* Initially hidden by default */
         display: none;
    }

     #quote-page .buttons.visible {
        opacity: 1;
     }

    /* 명언 페이지의 '새로운 명언 보기' 버튼 색상 */
    #quote-page .buttons #get-quote-button {
         background-color: #6a5acd; /* 부드러운 보라색 톤 */
         /* margin-bottom: 0; */ /* 하단 고정 버튼 컨테이너에 있으므로 margin 조정 */
         margin: 8px; /* 기본 버튼 마진 유지 */
    }
     #quote-page .buttons #get-quote-button:hover {
        background-color: #5a4ac0;
     }


  </style>
</head>
<body>

    <div id="initial-page">
        <h1 class="fade-element">루아의 감정 & 명언</h1>
        <p class="fade-element">당신의 마음을 들여다보거나<br>오늘의 힘이 되는 명언을 만나보세요.</p>
        <div class="buttons" id="initial-buttons">
            <button onclick="showEmotionTestStart()">감정 테스트 시작</button>
            <button onclick="showQuotePage()">오늘의 명언 보기</button>
        </div>
    </div>


    <div id="emotion-test-area">
        <h1 id="title" class="fade-element">루아의 감정테스트💙</h1>
        <p id="description" class="fade-element">당신의 감정 흐름을 알아보는 간단한 테스트입니다.<br>각 질문에 솔직하게 답해 주세요.</p>
        <div class="buttons" id="start-button">
            <button onclick="chooseEmotion()">OK</button>
        </div>

        <div id="emotion-choice" class="fade-element">
            <h1>당신이 궁금한 감정은 무엇인가요?</h1>
            <div class="buttons">
                <button onclick="selectEmotion('사랑')">💖 사랑</button>
                <button onclick="selectEmotion('슬픔')">🌧️ 슬픔</button>
                <button onclick="selectEmotion('기쁨')">🌞 기쁨</button>
                <button onclick="selectEmotion('두려움')">🛡️ 두려움</button>
                <button onclick="selectEmotion('용기')">🦋 용기</button>
            </div>
        </div>

        <h1 id="question" class="fade-element"></h1>
        <div class="buttons" id="answer-buttons">
            <button onclick="handleAnswer('yes')">Yes</button>
            <button onclick="handleAnswer('no')">No</button>
        </div>

        <div id="result" class="fade-element">
            <div class="result-text-area"></div>
        </div>

        <div class="pagination-buttons" id="result-buttons">
            <button id="prev-button" onclick="navigateResult(-1)">이전</button>
            <button id="next-button" onclick="navigateResult(1)">다음</button>
            <button id="restart-button" onclick="restartTest()">처음으로 돌아가기</button>
        </div>
    </div>

    <div id="quote-page">
        <h1>오늘의 명언</h1>
        <div id="quote-display">
            <p>버튼을 눌러 오늘의 명언을 확인하세요!</p>
        </div>
        <div class="buttons">
             <button id="get-quote-button">새로운 명언 보기</button>
             <button onclick="showInitialPage()">처음으로 돌아가기</button>
        </div>
    </div>


  <script src="quotes.js"></script> <script src="results_data.js"></script> <script>
    // --- DOM Element References ---
    const initialPageEl = document.getElementById('initial-page');
    const initialButtonsEl = document.getElementById('initial-buttons'); // 새로운 첫 화면 버튼 컨테이너

    const emotionTestAreaEl = document.getElementById('emotion-test-area'); // 감정 테스트 전체 영역
    const titleEl = document.getElementById('title');
    const descriptionEl = document.getElementById('description');
    const startButtonEl = document.getElementById('start-button'); // 감정 테스트 시작 버튼 컨테이너
    const emotionChoiceEl = document.getElementById('emotion-choice');
    const emotionButtonsEl = emotionChoiceEl.querySelector('.buttons'); // 감정 선택 버튼 컨테이너
    const questionEl = document.getElementById('question');
    const answerButtonsEl = document.getElementById('answer-buttons'); // 질문 답변 버튼 컨테이너
    const resultEl = document.getElementById('result');
    const resultTextAreaEl = resultEl.querySelector('.result-text-area'); // 결과 텍스트가 표시될 영역
    const resultButtonsEl = document.getElementById('result-buttons'); // 결과 페이지네이션 버튼 컨테이너
    const prevButtonEl = document.getElementById('prev-button'); // 이전 버튼
    const nextButtonEl = document.getElementById('next-button'); // 다음 버튼
    const restartButtonEl = document.getElementById('restart-button'); // 재시작 버튼 (감정 테스트)

    const quotePageEl = document.getElementById('quote-page'); // 명언 페이지 전체 영역
    const quoteDisplayEl = document.getElementById('quote-display'); // 명언 표시 영역
    const getQuoteButtonEl = document.getElementById('get-quote-button'); // 명언 보기 버튼
    const quotePageButtonsEl = quotePageEl.querySelector('.buttons'); // 명언 페이지 하단 버튼 컨테이너


    // --- Question Data Structure ---
    // (results_data.js에서 로드됩니다)


    // --- 명언 데이터 (quotes.js 파일에서 로드됩니다) ---
    // const quotes = [...]; // 이 배열 선언은 quotes.js 파일로 이동했습니다.


    // --- State Variables ---
    let selectedTree = null;
    let currentNode = null;
    let answers = [];
    let currentResultSections = []; // 결과를 섹션별로 저장할 배열
    let currentSectionIndex = 0; // 현재 표시 중인 결과 섹션 인덱스
    let slotAnimationInterval = null; // 슬롯 애니메이션 인터벌 ID


    // --- Utility Functions ---

    /**
     * Hides a specific content area by removing the 'visible' class and setting display to 'none' after transition.
     * @param {HTMLElement} element - The element to hide.
     */
    function hideContentArea(element) {
        element.classList.remove('visible');
        // Set display to none after fade out transition
        setTimeout(() => {
            element.style.display = 'none';
        }, 500); // Match CSS transition duration
    }

     /**
     * Hides a specific button container by removing the 'visible' class and setting display to 'none' immediately.
     * @param {HTMLElement} element - The button container element to hide.
     */
    function hideButtonContainer(element) {
         element.classList.remove('visible');
         element.style.display = 'none'; // Hide immediately
    }


    /**
     * Shows a specific content area by setting its display and adding the 'visible' class.
     * @param {HTMLElement} element - The element to show.
     * @param {string} [displayType='flex'] - The CSS display type ('flex' or 'block').
     */
    function showContentArea(element, displayType = 'flex') {
         // Ensure element starts hidden before fading in
        element.classList.remove('visible');
        element.style.opacity = 0; // Explicitly set opacity to 0

        element.style.display = displayType; // Set display type

        // Use a small timeout to allow the display change to render before fading in
        setTimeout(() => {
            element.classList.add('visible');
            element.style.opacity = 1; // Explicitly set opacity to 1 to trigger transition
        }, 50); // Short delay
    }

     /**
     * Shows a specific button container by setting its display and adding the 'visible' class.
     * @param {HTMLElement} element - The button container element to show.
     * @param {string} [displayType='flex'] - The CSS display type ('flex' or 'block').
     */
     function showButtonContainer(element, displayType = 'flex') {
         // Ensure element starts hidden before fading in
        element.classList.remove('visible');
        element.style.opacity = 0; // Explicitly set opacity to 0

        element.style.display = displayType; // Set display type

        // Use a small timeout to allow the display change to render before fading in
        setTimeout(() => {
            element.classList.add('visible');
            element.style.opacity = 1; // Explicitly set opacity to 1 to trigger transition
        }, 50); // Short delay
     }


    // --- Text Display Function (Smooth Fade-in) ---
    /**
     * Displays the given HTML string in the target element with a smooth fade-in animation.
     * @param {HTMLElement} element - The element to display into (e.g., resultTextAreaEl).
     * @param {string} htmlString - The HTML string to display.
     * @param {Function} onComplete - Callback function to execute after fade-in is complete.
     */
    function displayResultTextSmoothly(element, htmlString, onComplete) {
        // Fade out current content first
        element.style.opacity = 0;

        // Wait for fade-out to complete before changing content and fading in
        const fadeOutDelay = 300; // Shorter delay for fade-out
        const fadeInDuration = 1500; // Match CSS transition duration (1.5s) for fade-in

        setTimeout(() => {
            element.innerHTML = htmlString; // Set new content instantly

            // Fade in new content - use a very small delay to ensure transition triggers
            setTimeout(() => {
                element.style.opacity = 1;
                 // Execute onComplete callback after the fade-in transition duration
                setTimeout(() => {
                     if (onComplete) onComplete();
                }, fadeInDuration);
            }, 50); // Small delay to allow browser to register opacity: 0 before opacity: 1

        }, fadeOutDelay); // Use the defined fade out delay
    }

    // --- Function to process result section HTML (remove numbers) ---
    /**
     * Processes a single result section HTML string to remove leading numbers (e.g., "1. ").
     * Assumes the number is at the start of the text content within the first <p> or <strong> tag.
     * @param {string} sectionHTML - The HTML string for a single result section.
     * @returns {string} The processed HTML string with leading numbers removed.
     */
    function processResultSectionHTML(sectionHTML) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = sectionHTML.trim(); // Use trim() in case there's leading/trailing whitespace

        // Find the first text node or element that might contain the number prefix
        let targetNode = null;
        if (tempDiv.firstChild) {
             // Check if the first child is a text node or an element
            if (tempDiv.firstChild.nodeType === Node.TEXT_NODE) {
                targetNode = tempDiv.firstChild;
            } else if (tempDiv.firstChild.nodeType === Node.ELEMENT_NODE) {
                // If it's an element (like <p> or <strong>), look inside it
                const firstElement = tempDiv.firstChild;
                if (firstElement.firstChild && firstElement.firstChild.nodeType === Node.TEXT_NODE) {
                    targetNode = firstElement.firstChild;
                } else if (firstElement.tagName === 'STRONG' && firstElement.firstChild && firstElement.firstChild.nodeType === Node.TEXT_NODE) {
                     targetNode = firstElement.firstChild; // Target text inside <strong>
                } else {
                    // Look for text within nested elements if necessary (simple case)
                    const textNodes = [];
                    function findTextNodes(node) {
                        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim().length > 0) {
                            textNodes.push(node);
                        }
                        for (let i = 0; i < node.childNodes.length; i++) {
                            findTextNodes(node.childNodes[i]);
                        }
                    }
                    findTextNodes(firstElement);
                    if (textNodes.length > 0) {
                        targetNode = textNodes[0]; // Take the first non-empty text node found
                    }
                }
            }
        }


        if (targetNode && targetNode.nodeType === Node.TEXT_NODE) {
            let textContent = targetNode.textContent;
            // Use regex to find and remove leading number and dot (e.g., "1. ", " 2. ")
            const numberPrefixRegex = /^\s*\d+\.\s*/;
            if (numberPrefixRegex.test(textContent)) {
                targetNode.textContent = textContent.replace(numberPrefixRegex, '');
            }
        }

        // Return the modified HTML string
        return tempDiv.innerHTML;
    }

    // --- 명언 관련 함수 ---
    /**
     * Get a random quote from the quotes array.
     * @returns {string} A random quote.
     */
    function getRandomQuote() {
        // Ensure quotes array is loaded from quotes.js
        if (typeof quotes === 'undefined' || quotes.length === 0) {
             console.error("Quotes data not loaded or empty.");
             return "명언 데이터를 불러오지 못했습니다.";
        }
        const randomIndex = Math.floor(Math.random() * quotes.length);
        return quotes[randomIndex];
    }

    /**
     * Starts the slot machine-like animation for displaying a quote.
     */
    function startSlotAnimation() {
        const animationDuration = 3000; // Animation duration in milliseconds (increased for smoother feel)
        const frameRate = 70; // Time between quote changes in milliseconds (increased for slower change)
        const totalFrames = animationDuration / frameRate;
        let currentFrame = 0;

        // Disable the button during animation
        getQuoteButtonEl.disabled = true;

        // Clear any existing interval
        if (slotAnimationInterval) {
            clearInterval(slotAnimationInterval);
        }

        // Start the animation
        slotAnimationInterval = setInterval(() => {
            // Rapidly change content with quick fade
            quoteDisplayEl.style.opacity = 0; // Start fade out
            setTimeout(() => {
                 quoteDisplayEl.innerHTML = `<p>${getRandomQuote()}</p>`; // Change content
                 quoteDisplayEl.style.opacity = 1; // Start fade in
            }, 100); // Short delay for fade out

            currentFrame++;

            if (currentFrame >= totalFrames) {
                // Animation finished, stop interval and display the final quote
                clearInterval(slotAnimationInterval);
                slotAnimationInterval = null; // Reset interval ID
                displayFinalQuote();
            }
        }, frameRate);
    }

    /**
     * Displays the final random quote after the animation.
     */
    function displayFinalQuote() {
        const finalQuote = getRandomQuote();
        // Ensure final quote fades in smoothly
        quoteDisplayEl.style.opacity = 0; // Fade out current (last animated) quote
        setTimeout(() => {
            quoteDisplayEl.innerHTML = `<p>${finalQuote}</p>`; // Set final quote
            quoteDisplayEl.style.opacity = 1; // Fade in final quote
             // Re-enable the button after the final fade-in completes
            setTimeout(() => {
                 getQuoteButtonEl.disabled = false;
            }, 500); // Match the CSS transition duration for fade-in
        }, 300); // Match the fadeOutDelay used in displayResultTextSmoothly, or adjust as needed
    }


    // --- Page Transition Functions ---

    // Show the initial page
    function showInitialPage() {
        // Hide all other content areas and buttons first
        hideContentArea(emotionTestAreaEl);
        hideContentArea(quotePageEl);
        hideButtonContainer(startButtonEl);
        hideButtonContainer(answerButtonsEl);
        hideButtonContainer(resultButtonsEl);
        hideButtonContainer(emotionButtonsEl);
        hideButtonContainer(quotePageButtonsEl);


        // Show initial page elements
        showContentArea(initialPageEl, 'flex'); // Show initial page container
        // Fade in text elements and buttons within the initial page
        setTimeout(() => {
             initialPageEl.querySelectorAll('.fade-element').forEach(el => el.classList.add('visible'));
             showButtonContainer(initialButtonsEl, 'flex');
        }, 100); // Short delay after initial page container fade-in starts
    }


    // Show the emotion test start page
    function showEmotionTestStart() {
        // Hide all other areas
        hideContentArea(initialPageEl);
        hideContentArea(quotePageEl);
        hideButtonContainer(initialButtonsEl);
        hideButtonContainer(quotePageButtonsEl);


        // Reset emotion test state
        selectedTree = null;
        currentNode = null;
        answers = [];
        currentResultSections = [];
        currentSectionIndex = 0;
        resultTextAreaEl.innerHTML = ''; // Clear result text


        // Show emotion test area
        showContentArea(emotionTestAreaEl, 'flex'); // Show emotion test area container

        // Fade in emotion test start elements
        setTimeout(() => {
            // Ensure display is set before adding visible class for fade-in
            titleEl.style.display = 'block';
            descriptionEl.style.display = 'block';
            // startButtonEl.style.display = 'flex'; // Handled by showButtonContainer

            // Add visible class after a short delay to trigger fade-in
            setTimeout(() => {
                titleEl.classList.add('visible');
                descriptionEl.classList.add('visible');
                showButtonContainer(startButtonEl, 'flex'); // Show start button container
            }, 50); // Short delay
        }, 100); // Short delay after emotion test area fade-in starts
    }

    // Show the quote page
    function showQuotePage() {
        // Hide all other areas
        hideContentArea(initialPageEl);
        hideContentArea(emotionTestAreaEl);
        hideButtonContainer(initialButtonsEl);
        hideButtonContainer(startButtonEl);
        hideButtonContainer(answerButtonsEl);
        hideButtonContainer(resultButtonsEl);
        hideButtonContainer(emotionButtonsEl);


        // Reset quote page state
        if (slotAnimationInterval) {
            clearInterval(slotAnimationInterval);
            slotAnimationInterval = null;
        }
        getQuoteButtonEl.disabled = false;
        quoteDisplayEl.innerHTML = '<p>버튼을 눌러 오늘의 명언을 확인하세요!</p>'; // Reset quote display


        // Show quote page
        showContentArea(quotePageEl, 'flex'); // Show quote page container

        // Fade in quote page elements
        setTimeout(() => {
            quotePageEl.querySelectorAll('.fade-element').forEach(el => el.classList.add('visible')); // Fade in title etc.
            // Fade in the buttons on the quote page
             showButtonContainer(quotePageButtonsEl, 'flex');
        }, 100); // Short delay after quote page container fade-in starts
    }


    // --- Emotion Test Functions ---

    // Start the test: Hide emotion test start, show emotion choice
    function chooseEmotion() {
        console.log('chooseEmotion called'); // Debugging log
        // Fade out emotion test start elements
        titleEl.classList.remove('visible');
        descriptionEl.classList.remove('visible');
        hideButtonContainer(startButtonEl); // Hide start button container immediately


        setTimeout(() => {
            // Hide emotion test start elements after fade out
            titleEl.style.display = 'none';
            descriptionEl.style.display = 'none';
            // startButtonEl.style.display = 'none'; // Handled by hideButtonContainer


            // Clear previous result stuff
            resultTextAreaEl.innerHTML = '';
            hideButtonContainer(resultButtonsEl); // Hide result buttons
            resultEl.classList.remove('visible');
            resultEl.style.display = 'none'; // Ensure result area is hidden


            // Show emotion choice div and its buttons div
            emotionChoiceEl.style.display = 'block'; // emotionChoiceEl is block
            showButtonContainer(emotionButtonsEl, 'flex'); // Show emotion choice buttons container


            // Fade in emotion choice div and its buttons div
            setTimeout(() => {
                emotionChoiceEl.classList.add('visible');
                // emotionButtonsEl.classList.add('visible'); // Handled by showButtonContainer
            }, 50); // Short delay before adding visible class

        }, 500); // Match CSS transition duration for fade out
    }

    // Emotion selected: Hide emotion choice, show first question
    function selectEmotion(emotion) {
      selectedTree = questionTree[emotion];
      currentNode = selectedTree;
      answers = []; // Reset answers for the new emotion

      // Fade out emotion choice elements
      emotionChoiceEl.classList.remove('visible');
      hideButtonContainer(emotionButtonsEl); // Hide emotion choice buttons immediately


      setTimeout(() => {
          // Hide emotion choice elements after fade out
          emotionChoiceEl.style.display = 'none';
          // emotionButtonsEl.style.display = 'none'; // Handled by hideButtonContainer

          // Show question element
          questionEl.style.display = 'block';
          // Show answer buttons (fixed)
          showButtonContainer(answerButtonsEl, 'flex'); // Show answer buttons container


          // Fade in question element and answer buttons
          setTimeout(() => {
               questionEl.classList.add('visible');
               // answerButtonsEl.classList.add('visible'); // Handled by showButtonContainer
               displayQuestion(); // Set the first question text
          }, 50); // Short delay before adding visible class

      }, 500); // Wait for fade out
    }

    // Display the current question
    function displayQuestion() {
      if (currentNode && currentNode.question) {
        questionEl.innerText = currentNode.question;
        // Ensure question element is visible (it might have been faded out)
        if (!questionEl.classList.contains('visible')) {
            questionEl.style.display = 'block';
            setTimeout(() => questionEl.classList.add('visible'), 50);
        }
         // Ensure answer buttons are visible (fixed)
        if (!answerButtonsEl.classList.contains('visible')) {
            answerButtonsEl.style.display = 'flex'; // Fixed position, set display to flex explicitly
            setTimeout(() => answerButtonsEl.classList.add('visible'), 50);
        }

      } else {
        // No more questions, calculate and show the result
        calculateResult();
      }
    }

    // Handle user's answer (Yes/No)
    function handleAnswer(answer) {
      if (currentNode && currentNode[answer]) {
        answers.push(answer);
        currentNode = currentNode[answer];

        // Fade out current question and answer buttons
        questionEl.classList.remove('visible');
        hideButtonContainer(answerButtonsEl); // Hide answer buttons immediately


        setTimeout(() => {
            // Hide elements after fade out
            questionEl.style.display = 'none';
            // answerButtonsEl.style.display = 'none'; // Handled by hideButtonContainer


            // Check if there's a next question before fading in
            if (currentNode && currentNode.question) {
                 displayQuestion(); // Update text and fade in question and answer buttons
            } else {
                // No more questions, transition to result
                // Fade in the result element within the emotion test area
                resultEl.style.display = 'block'; // Result is block within flex container
                setTimeout(() => resultEl.classList.add('visible'), 50);
                calculateResult(); // Calculate and display the result text
            }
        }, 500); // Wait for fade out
      }
    }

    // Calculate and display the final result
    function calculateResult() {
      // Hide question and answer elements if they are still visible
      questionEl.classList.remove('visible');
      hideButtonContainer(answerButtonsEl); // Ensure fixed answer buttons are hidden

      setTimeout(() => {
          questionEl.style.display = 'none';
          // answerButtonsEl.style.display = 'none'; // Handled by hideButtonContainer
      }, 500);

      // 현재 선택된 감정과 답변 경로를 가져옵니다.
      const emotion = Object.keys(questionTree).find(key => questionTree[key] === selectedTree);
      const path = answers.join('-');

      // results_data.js 파일의 resultTexts 객체에서 해당 감정과 경로의 결과 텍스트를 가져옵니다.
      let fullResultHTML = "<p>결과를 불러오지 못했습니다.</p>"; // 기본 오류 메시지 (HTML 형식)

      // resultTexts 객체가 로드되었는지, 그리고 해당 감정과 경로의 데이터가 존재하는지 확인
      if (typeof resultTexts !== 'undefined' && resultTexts[emotion] && resultTexts[emotion][path]) {
          fullResultHTML = resultTexts[emotion][path];
      }

      // 결과 HTML을 <hr> 태그를 기준으로 섹션으로 분할합니다.
      // 각 섹션의 시작 부분에 <hr>이 있을 수 있으므로, 첫 번째 요소는 건너뛰거나 처리해야 할 수 있습니다.
      // 여기서는 <hr>로 분할하고 각 섹션의 앞뒤 공백을 제거합니다.
      const sections = fullResultHTML.split('<hr>').map(section => section.trim()).filter(section => section.length > 0);

      // 분할된 각 섹션에서 아라비아 숫자를 제거합니다.
      currentResultSections = sections.map(sectionHTML => processResultSectionHTML(sectionHTML));
      currentSectionIndex = 0; // 첫 번째 섹션부터 시작

      // 결과 영역은 이미 showContentArea에서 visible 처리됨.
      // 이제 결과 텍스트 영역에 첫 번째 섹션을 부드러운 페이드 인 애니메이션으로 표시합니다.
      displayResultTextSmoothly(resultTextAreaEl, currentResultSections[currentSectionIndex], () => {
           // 텍스트 표시 완료 후 결과 버튼 컨테이너를 보이게 합니다.
           showButtonContainer(resultButtonsEl, 'flex'); // Show result buttons container
           updateResultButtons(); // 버튼 상태 업데이트
      });
    }

    // 특정 결과 섹션을 표시하는 함수 (부드러운 페이드 인)
    function displayResultSection(index) {
        if (index >= 0 && index < currentResultSections.length) {
            // 현재 섹션을 resultTextAreaEl에 부드러운 페이드 인 애니메이션으로 표시
            displayResultTextSmoothly(resultTextAreaEl, currentResultSections[index], () => {
                // 텍스트 표시 완료 후 버튼 상태 업데이트
                currentSectionIndex = index; // 인덱스 업데이트는 애니메이션 완료 후
                updateResultButtons();
            });
        }
    }

    // 결과 페이지네이션 버튼 상태를 업데이트하는 함수
    function updateResultButtons() {
        // 이전 버튼 상태
        if (currentSectionIndex > 0) {
            prevButtonEl.style.display = 'inline-block';
        } else {
            prevButtonEl.style.display = 'none';
        }

        // 다음 버튼 상태
        if (currentSectionIndex < currentResultSections.length - 1) {
            nextButtonEl.style.display = 'inline-block';
            restartButtonEl.style.display = 'none'; // 다음 버튼이 있으면 재시작 버튼 숨김
        } else {
            nextButtonEl.style.display = 'none'; // 마지막 섹션이면 다음 버튼 숨김
            restartButtonEl.style.display = 'inline-block'; // 마지막 섹션이면 재시작 버튼 표시
        }

        // 재시작 버튼은 마지막 섹션에서만 표시되므로 위에서 처리
        // prevButton과 nextButton이 모두 숨겨지면 (섹션이 1개 이하), restartButton만 보이게 됨.
        if (currentResultSections.length <= 1) {
             prevButtonEl.style.display = 'none';
             nextButtonEl.style.display = 'none';
             restartButtonEl.style.display = 'inline-block';
        }
    }


    // 결과 페이지네이션 탐색 함수
    function navigateResult(direction) {
        const newIndex = currentSectionIndex + direction;
        displayResultSection(newIndex);
    }


    // Restart the test: Hide result, show initial screen
    function restartTest() {
        // Fade out result elements
        resultEl.classList.remove('visible');
        hideButtonContainer(resultButtonsEl); // Hide result buttons container immediately

        setTimeout(() => {
            // Hide elements after fade out
            resultEl.style.display = 'none'; // Hide result area
            // resultButtonsEl.style.display = 'none'; // Handled by hideButtonContainer

            // Reset state variables
            selectedTree = null;
            currentNode = null;
            answers = [];
            currentResultSections = []; // 결과 섹션 배열 초기화
            currentSectionIndex = 0; // 인덱스 초기화


            // Hide emotion test specific elements that might still be visible
            emotionChoiceEl.style.display = 'none';
            questionEl.style.display = 'none';
            answerButtonsEl.style.display = 'none'; // Ensure fixed answer buttons are hidden
            emotionChoiceEl.classList.remove('visible');
            questionEl.classList.remove('visible');
            answerButtonsEl.classList.remove('visible');

            // Go back to the initial page
            showInitialPage();

        }, 500); // Wait for fade out
    }

    // --- Initial Load ---
    window.onload = () => {
        // Initially hide all main content areas and button containers using CSS display: none
        // This is already set in CSS, so no need to explicitly set here on load.
        // Just ensure opacity is 0 for fade-in.
        initialPageEl.style.opacity = 0;
        emotionTestAreaEl.style.opacity = 0;
        quotePageEl.style.opacity = 0;

        const allButtonContainers = document.querySelectorAll('.buttons, .pagination-buttons');
        allButtonContainers.forEach(container => {
             container.style.opacity = 0;
        });


        // Then show the initial page
        showInitialPage();
    };

    // --- Event Listeners ---
    getQuoteButtonEl.addEventListener('click', startSlotAnimation);


  </script>
</body>
</html>
