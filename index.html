<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ë£¨ì•„ì˜ ê°ì •í…ŒìŠ¤íŠ¸ğŸ’™</title>
  <link href="https://fonts.googleapis.com/css2?family=Gowun+Batang:wght@400;700&display=swap" rel="stylesheet">

  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center; /* ìˆ˜ì§ ì¤‘ì•™ ì •ë ¬ ìœ ì§€ */
      min-height: 100vh;
      margin: 0;
      padding: 20px;
      /* ê¸€ê¼´ ë³€ê²½ */
      font-family: 'Gowun Batang', serif;
      /* ë°°ê²½ìƒ‰ ì¡°ì •: ëˆˆì´ í¸í•˜ê³  ë”°ëœ»í•œ ëŠë‚Œì˜ ìƒ‰ìƒ */
      background-color: #fff0e0; /* ë¶€ë“œëŸ¬ìš´ ë³µìˆ­ì•„/ë² ì´ì§€ í†¤ ìœ ì§€ */
      color: #333; /* ê¸°ë³¸ í…ìŠ¤íŠ¸ ìƒ‰ìƒ */
      box-sizing: border-box;
      padding-bottom: 80px; /* ê³ ì • ë²„íŠ¼ ì˜ì—­ë§Œí¼ í•˜ë‹¨ íŒ¨ë”© ì¶”ê°€ */
    }

    /* Text elements that will fade */
    .fade-element {
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
      text-align: center;
      margin-bottom: 20px;
      width: 100%;
      max-width: 600px;
    }

    /* Class to make elements visible */
    .fade-element.visible {
      opacity: 1;
    }

    h1 {
      font-size: 1.8em;
      color: #5a3e36; /* ì œëª© ìƒ‰ìƒ ì¡°ì • */
      margin-bottom: 30px; /* ì œëª©ê³¼ ë‚´ìš© ê°„ê²© ì¶”ê°€ */
      font-weight: bold; /* ì§ˆë¬¸ í…ìŠ¤íŠ¸ êµµê¸° (ê¸°ë³¸ h1ë³´ë‹¤ ëª…ì‹œì ìœ¼ë¡œ) */
    }

    p {
        font-size: 1.1em;
        line-height: 1.6;
    }

    /* ì‹œì‘/ì§ˆë¬¸ í˜ì´ì§€ ë²„íŠ¼ ì»¨í…Œì´ë„ˆ - ìœ„ì¹˜ ê³ ì • */
    .buttons {
      /* margin-top: 20px; */ /* Fixed position, margin-top might not be needed for positioning */
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s ease-in-out 0.3s;
      width: 100%;
      /* ìœ„ì¹˜ ê³ ì • */
      position: fixed;
      bottom: 0; /* í•˜ë‹¨ì— ê³ ì • */
      left: 0;
      width: 100%; /* ë„ˆë¹„ ì „ì²´ */
      background-color: #fff0e0; /* ë°°ê²½ìƒ‰ê³¼ ë™ì¼í•˜ê²Œ ì„¤ì • */
      padding: 10px 20px; /* íŒ¨ë”© ì¶”ê°€ */
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1); /* ìƒë‹¨ ê·¸ë¦¼ì */
      box-sizing: border-box; /* íŒ¨ë”© í¬í•¨ */
      z-index: 1000; /* ë‹¤ë¥¸ ìš”ì†Œ ìœ„ë¡œ ì˜¤ë„ë¡ ì„¤ì • */
      display: flex; /* ë²„íŠ¼ ì •ë ¬ */
      justify-content: center; /* ê°€ìš´ë° ì •ë ¬ */
      align-items: center;
      flex-wrap: wrap; /* ì‘ì€ í™”ë©´ì—ì„œ ì¤„ë°”ê¿ˆ */
    }


    .buttons.visible {
        opacity: 1;
    }

    button {
      margin: 8px;
      padding: 12px 25px;
      font-size: 1em;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      /* ë²„íŠ¼ ìƒ‰ìƒ ì¡°ì •: ë°°ê²½ìƒ‰ê³¼ ì–´ìš¸ë¦¬ë„ë¡ */
      background-color: #ff914d; /* ë”°ëœ»í•œ ì˜¤ë Œì§€ í†¤ */
      color: white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s ease, transform 0.1s ease;
    }

    button:hover {
      background-color: #357abd; /* í˜¸ë²„ ì‹œ ì•½ê°„ ì–´ë‘¡ê²Œ */
    }

    button:active {
        transform: scale(0.98);
    }

    #result {
      font-size: 1.3em;
      color: #333;
      margin-top: 20px;
      text-align: center;
      max-width: 600px;
      line-height: 1.6;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
      margin-bottom: 80px; /* ê²°ê³¼ í…ìŠ¤íŠ¸ í•˜ë‹¨ì—ë„ ê³ ì • ë²„íŠ¼ ì˜ì—­ë§Œí¼ íŒ¨ë”© ì¶”ê°€ */
    }

    #result.visible {
        opacity: 1;
    }

    #result .result-text-area {
        min-height: 150px;
        text-align: left;
        padding: 0;
        border: none;
        border-radius: 0;
        background-color: transparent;
        box-shadow: none;
        /* í˜ì´ì§€ë„¤ì´ì…˜ ì „í™˜ ì• ë‹ˆë©”ì´ì…˜ - opacity ì „í™˜ ì‹œê°„ ì¡°ì • */
        transition: opacity 1.5s ease-in-out; /* ì´ì „ 0.3sì—ì„œ 1.5së¡œ ì¦ê°€ */
    }

     #result .result-text-area p {
         margin-bottom: 10px;
         font-weight: 500; /* ì¼ë°˜ í…ìŠ¤íŠ¸ êµµê¸° ì¡°ì • (ì§ˆë¬¸ í…ìŠ¤íŠ¸ì™€ ìœ ì‚¬í•˜ê²Œ) */
     }

     #result .result-text-area strong {
         display: block;
         margin-bottom: 5px;
         color: #7a5b50; /* ì œëª© ë¶€ë¶„ ìƒ‰ìƒ ì¡°ì • */
         font-weight: bold; /* strong íƒœê·¸ëŠ” ë” ì§„í•˜ê²Œ */
     }

     #result .result-text-area hr {
         margin: 20px 0;
         border: 0;
         border-top: 1px solid #e0d0c0; /* êµ¬ë¶„ì„  ìƒ‰ìƒ ì¡°ì • */
     }


    #emotion-choice {
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
      width: 100%;
      max-width: 600px;
    }

    #emotion-choice.visible {
        opacity: 1;
    }

    #emotion-choice h1 {
      margin-bottom: 10px;
    }

    #emotion-choice .buttons button {
      margin: 10px;
      /* ê°ì • ì„ íƒ ë²„íŠ¼ ìƒ‰ìƒ ì¡°ì • */
      background-color: #ffc107; /* ë”°ëœ»í•œ ë…¸ë€ìƒ‰ í†¤ */
    }
     #emotion-choice .buttons button:hover {
      background-color: #ffb300;
     }

    /* Hide elements initially using opacity, manage display via JS */
    /* Removed display: none here to rely on JS for initial state */
    /* #question, #answer-buttons, #result, #emotion-choice { display: none; } */


    /* í˜ì´ì§€ë„¤ì´ì…˜ ë²„íŠ¼ ì»¨í…Œì´ë„ˆ - ìœ„ì¹˜ ê³ ì • (buttons í´ë˜ìŠ¤ì™€ ë™ì¼í•˜ê²Œ ì„¤ì •) */
    #result-buttons.pagination-buttons { /* ë” ëª…í™•í•˜ê²Œ ì§€ì • */
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
        display: flex; /* Always flex for fixed position */
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        /* ìœ„ì¹˜ ê³ ì • */
        position: fixed;
        bottom: 0; /* í•˜ë‹¨ì— ê³ ì • */
        left: 0;
        width: 100%; /* ë„ˆë¹„ ì „ì²´ */
        background-color: #fff0e0; /* ë°°ê²½ìƒ‰ê³¼ ë™ì¼í•˜ê²Œ ì„¤ì • */
        padding: 10px 20px; /* íŒ¨ë”© ì¶”ê°€ */
        box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1); /* ìƒë‹¨ ê·¸ë¦¼ì */
        box-sizing: border-box; /* íŒ¨ë”© í¬í•¨ */
        z-index: 1000; /* ë‹¤ë¥¸ ìš”ì†Œ ìœ„ë¡œ ì˜¤ë„ë¡ ì„¤ì • */
    }

    #result-buttons.pagination-buttons.visible {
        opacity: 1;
    }


    #result-buttons.pagination-buttons button {
        margin: 5px 8px;
    }


  </style>
</head>
<body>

  <h1 id="title" class="fade-element">ë£¨ì•„ì˜ ê°ì •í…ŒìŠ¤íŠ¸ğŸ’™</h1> <p id="description" class="fade-element">ë‹¹ì‹ ì˜ ê°ì • íë¦„ì„ ì•Œì•„ë³´ëŠ” ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤.<br>ê° ì§ˆë¬¸ì— ì†”ì§í•˜ê²Œ ë‹µí•´ ì£¼ì„¸ìš”.</p>
  <div class="buttons" id="start-button">
    <button onclick="chooseEmotion()">OK</button>
  </div>

  <div id="emotion-choice" class="fade-element">
    <h1>ë‹¹ì‹ ì´ ê¶ê¸ˆí•œ ê°ì •ì€ ë¬´ì—‡ì¸ê°€ìš”?</h1>
    <div class="buttons">
      <button onclick="selectEmotion('ì‚¬ë‘')">ğŸ’– ì‚¬ë‘</button>
      <button onclick="selectEmotion('ìŠ¬í””')">ğŸŒ§ï¸ ìŠ¬í””</button>
      <button onclick="selectEmotion('ê¸°ì¨')">ğŸŒ ê¸°ì¨</button>
      <button onclick="selectEmotion('ë‘ë ¤ì›€')">ğŸ›¡ï¸ ë‘ë ¤ì›€</button>
      <button onclick="selectEmotion('ìš©ê¸°')">ğŸ¦‹ ìš©ê¸°</button>
    </div>
  </div>

  <h1 id="question" class="fade-element"></h1>
  <div class="buttons" id="answer-buttons">
    <button onclick="handleAnswer('yes')">Yes</button>
    <button onclick="handleAnswer('no')">No</button>
  </div>

  <div id="result" class="fade-element">
      <div class="result-text-area"></div>
      </div>

  <div class="pagination-buttons" id="result-buttons">
      <button id="prev-button" onclick="navigateResult(-1)">ì´ì „</button>
      <button id="next-button" onclick="navigateResult(1)">ë‹¤ìŒ</button>
      <button id="restart-button" onclick="restartTest()">ì²˜ìŒìœ¼ë¡œ ëŒì•„ê°€ê¸°</button>
  </div>


  <script src="results_data.js"></script>
  <script>
    // --- DOM Element References ---
    const titleEl = document.getElementById('title');
    const descriptionEl = document.getElementById('description');
    const startButtonEl = document.getElementById('start-button');
    const emotionChoiceEl = document.getElementById('emotion-choice');
    const emotionButtonsEl = emotionChoiceEl.querySelector('.buttons'); // Get buttons inside emotion choice
    const questionEl = document.getElementById('question');
    const answerButtonsEl = document.getElementById('answer-buttons');
    const resultEl = document.getElementById('result');
    const resultTextAreaEl = resultEl.querySelector('.result-text-area'); // ê²°ê³¼ í…ìŠ¤íŠ¸ê°€ í‘œì‹œë  ì˜ì—­
    const resultButtonsEl = document.getElementById('result-buttons'); // ê²°ê³¼ í˜ì´ì§€ë„¤ì´ì…˜ ë²„íŠ¼ ì»¨í…Œì´ë„ˆ
    const prevButtonEl = document.getElementById('prev-button'); // ì´ì „ ë²„íŠ¼
    const nextButtonEl = document.getElementById('next-button'); // ë‹¤ìŒ ë²„íŠ¼
    const restartButtonEl = document.getElementById('restart-button'); // ì¬ì‹œì‘ ë²„íŠ¼


    // --- Question Data Structure ---
    // (ì´ ë¶€ë¶„ì€ ë³€ê²½ ì—†ìŒ)
    const questionTree = {
      'ì‚¬ë‘': {
        question: 'ìµœê·¼, ëˆ„êµ°ê°€ë¥¼ ìƒê°í•˜ë©´ ë§ˆìŒì´ ë”°ëœ»í•´ì§„ ì ì´ ìˆë‚˜ìš”?',
        yes: {
          question: 'ê·¸ ê°ì •ì€ ì§€ê¸ˆë„ ê³„ì†ë˜ê³  ìˆë‚˜ìš”?',
          yes: {
            question: 'ê·¸ ì‚¬ëŒê³¼ í•¨ê»˜í–ˆë˜ ê¸°ì–µì´ ë¯¸ì†Œë¥¼ ì§“ê²Œ í•˜ë‚˜ìš”?',
            yes: {},
            no: {}
          },
          no: {
            question: 'ê·¸ ê¸°ì–µì€ ì•„í””ë³´ë‹¤ëŠ” ë”°ëœ»í•¨ì´ ë‚¨ì•„ìˆë‚˜ìš”?',
            yes: {},
            no: {}
          }
        },
        no: {
          question: 'ë§ˆìŒì„ ìš¸ë¦¬ëŠ” ìƒˆë¡œìš´ ì—°ê²°ì„ ì°¾ê³  ì‹¶ë‚˜ìš”?',
          yes: {
            question: 'ê·¸ ìƒˆë¡œìš´ ì—°ê²°ì€ ê¸°ëŒ€ë³´ë‹¤ëŠ” ë‘ë ¤ì›€ì´ í°ê°€ìš”?',
            yes: {},
            no: {}
          },
          no: {
            question: 'í˜„ì¬ ë‹¹ì‹ ì€ í˜¼ì ìˆì–´ë„ í¸ì•ˆí•¨ì„ ëŠë¼ë‚˜ìš”?',
            yes: {},
            no: {}
          }
        }
      },
      'ìŠ¬í””': {
        question: 'ìµœê·¼, ë§ˆìŒì´ ë¬´ê±°ì› ë˜ ìˆœê°„ì´ ìˆì—ˆë‚˜ìš”?',
        yes: {
          question: 'ê·¸ ë¬´ê±°ì›€ì´ ì˜¤ë˜ ì§€ì†ë˜ì—ˆë‚˜ìš”?',
          yes: {
            question: 'ëˆ„êµ°ê°€ì—ê²Œ ê¸°ëŒ€ê³  ì‹¶ì—ˆë˜ ì ì´ ìˆë‚˜ìš”?',
            yes: {},
            no: {}
          },
          no: {
            question: 'í˜¼ì ì´ê²¨ë‚´ë ¤ í–ˆë‚˜ìš”?',
            yes: {},
            no: {}
          }
        },
        no: {
          question: 'ê°€ë” ì´ìœ  ì—†ì´ ê³µí—ˆí•¨ì„ ëŠë¼ë‚˜ìš”?',
          yes: {
            question: 'ê·¸ ê³µí—ˆí•¨ì„ ì±„ìš°ë ¤ ë…¸ë ¥í–ˆë‚˜ìš”?',
            yes: {},
            no: {}
          },
          no: {
            question: 'ê·¸ ê³µí—ˆí•¨ì„ ì™¸ë©´í•˜ë ¤ í–ˆë‚˜ìš”?',
            yes: {},
            no: {}
          }
        }
      },
      'ê¸°ì¨': {
        question: 'ìµœê·¼, íŠ¹ë³„í•œ ì´ìœ  ì—†ì´ ì›ƒì—ˆë˜ ìˆœê°„ì´ ìˆë‚˜ìš”?',
        yes: {
          question: 'ê·¸ ì›ƒìŒì´ ì˜¤ë˜ ê¸°ì–µì— ë‚¨ì•˜ë‚˜ìš”?',
          yes: {
            question: 'ëˆ„êµ°ê°€ì™€ ê·¸ ìˆœê°„ì„ ë‚˜ëˆ„ì—ˆë‚˜ìš”?',
            yes: {},
            no: {}
          },
          no: {
            question: 'í˜¼ìë§Œì˜ ì¦ê±°ì›€ìœ¼ë¡œ ê°„ì§í–ˆë‚˜ìš”?',
            yes: {},
            no: {}
          }
        },
        no: {
          question: 'ê¸°ì¨ì„ ì°¾ê¸° ìœ„í•´ ë¬´ì–¸ê°€ ì‹œë„í–ˆë‚˜ìš”?',
          yes: {
            question: 'ê·¸ ì‹œë„ê°€ ë‹¹ì‹ ì„ ì¡°ê¸ˆì´ë¼ë„ í–‰ë³µí•˜ê²Œ í–ˆë‚˜ìš”?',
            yes: {},
            no: {}
          },
          no: {
            question: 'ì‹œë„ì¡°ì°¨ ë¶€ë‹´ìŠ¤ëŸ½ê²Œ ëŠê»´ì¡Œë‚˜ìš”?',
            yes: {},
            no: {}
          }
        }
      },
      'ë‘ë ¤ì›€': {
        question: 'ìµœê·¼, ì‹œì‘í•˜ê¸° ì „ì— ë§ì„¤ì˜€ë˜ ì¼ì´ ìˆì—ˆë‚˜ìš”?',
        yes: {
          question: 'ê·¸ ë§ì„¤ì„ì€ ë‘ë ¤ì›€ ë•Œë¬¸ì´ì—ˆë‚˜ìš”?',
          yes: {
            question: 'ë‘ë ¤ì›€ì„ ë„˜ì–´ì„œ í–‰ë™í•œ ì ì´ ìˆë‚˜ìš”?',
            yes: {},
            no: {}
          },
          no: {
            question: 'ë‹¤ë¥¸ ì´ìœ ë¡œ ë¨¸ë­‡ê±°ë ¸ë‚˜ìš”?',
            yes: {},
            no: {}
          }
        }
      },
      'ìš©ê¸°': {
        question: 'ìµœê·¼, ë¬´ì–¸ê°€ì— ë§ì„œì•¼ í–ˆë˜ ìˆœê°„ì´ ìˆì—ˆë‚˜ìš”?',
        yes: {
          question: 'ê·¸ ìˆœê°„ì„ í†µí•´ ì„±ì¥í–ˆë‹¤ê³  ëŠë¼ë‚˜ìš”?',
          yes: {
            question: 'ë‹¤ì‹œ ê°™ì€ ìƒí™©ì´ ì™€ë„ ë§ì„¤ ìˆ˜ ìˆë‚˜ìš”?',
            yes: {},
            no: {}
          },
          no: {
            question: 'ê·¸ ìˆœê°„ì´ ì•„ì§ ë§ˆìŒì— ë‚¨ì•„ìˆë‚˜ìš”?',
            yes: {},
            no: {}
          }
        },
        no: {
          question: 'ìš©ê¸°ë¥¼ ë‚´ì•¼ í•  ìƒí™©ì„ í”¼í•œ ì ì´ ìˆë‚˜ìš”?',
          yes: {
            question: 'ê·¸ í”¼í•œ ì„ íƒì„ í›„íšŒí•œ ì ì´ ìˆë‚˜ìš”?',
            yes: {},
            no: {}
          },
          no: {
            question: 'í”¼í•œ ê²ƒì´ ìµœì„ ì˜ ì„ íƒì´ì—ˆë‹¤ê³  ëŠë¼ë‚˜ìš”?',
            yes: {},
            no: {}
          }
        }
      }
    };

    // --- State Variables ---
    let selectedTree = null;
    let currentNode = null;
    let answers = [];
    let currentResultSections = []; // ê²°ê³¼ë¥¼ ì„¹ì…˜ë³„ë¡œ ì €ì¥í•  ë°°ì—´
    let currentSectionIndex = 0; // í˜„ì¬ í‘œì‹œ ì¤‘ì¸ ê²°ê³¼ ì„¹ì…˜ ì¸ë±ìŠ¤
    // revealSpeed ë³€ìˆ˜ëŠ” ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.


    // --- Utility Function for Fade Transitions ---
    /**
     * Fades out an element, executes a callback, then fades in another element.
     * Handles fixed position elements by managing display and opacity.
     * @param {HTMLElement} elementOut - The element to fade out.
     * @param {HTMLElement} elementIn - The element to fade in.
     * @param {Function} [callback] - Optional function to execute after fade out, before fade in.
     */
    function fadeTransition(elementOut, elementIn, callback) {
        const isElementOutFixed = elementOut && (elementOut.style.position === 'fixed' || window.getComputedStyle(elementOut).position === 'fixed');
        const isElementInFixed = elementIn && (elementIn.style.position === 'fixed' || window.getComputedStyle(elementIn).position === 'fixed');


        if (elementOut) {
            elementOut.classList.remove('visible');
            // Wait for fade-out transition to complete before hiding
            setTimeout(() => {
                if (!isElementOutFixed) { // Only hide non-fixed elements with display: none
                   elementOut.style.display = 'none';
                } else { // For fixed elements, set display to none after fade out
                     elementOut.style.display = 'none';
                }
                if (callback) callback(); // Execute callback if provided

                if (elementIn) {
                    if (!isElementInFixed) { // Only show non-fixed elements with display: block
                        elementIn.style.display = 'block';
                    } else { // For fixed elements, set display first if needed (e.g., from none)
                         // Check if display is none and set it to flex/block before fading in
                        if (window.getComputedStyle(elementIn).display === 'none') {
                             elementIn.style.display = elementIn.classList.contains('buttons') || elementIn.classList.contains('pagination-buttons') ? 'flex' : 'block';
                        }
                    }
                    // Use another timeout to ensure display change is rendered before adding class
                    setTimeout(() => elementIn.classList.add('visible'), 50); // Short delay
                }
            }, 500); // Match CSS transition duration
        } else {
            // If no element to fade out, just execute callback and fade in
            if (callback) callback();
             if (elementIn) {
                 if (!isElementInFixed) {
                    elementIn.style.display = 'block';
                 } else {
                     if (window.getComputedStyle(elementIn).display === 'none') {
                          elementIn.style.display = elementIn.classList.contains('buttons') || elementIn.classList.contains('pagination-buttons') ? 'flex' : 'block';
                     }
                 }
                setTimeout(() => elementIn.classList.add('visible'), 50);
            }
        }
    }

     /**
     * Fades out multiple elements simultaneously, then executes a callback.
     * Handles fixed position elements by managing display and opacity.
     * @param {HTMLElement[]} elementsOut - Array of elements to fade out.
     * @param {Function} [callback] - Optional function after fade out.
     */
    function fadeOutMultiple(elementsOut, callback) {
        elementsOut.forEach(el => el.classList.remove('visible'));

        setTimeout(() => {
            elementsOut.forEach(el => {
                 const isElementFixed = el && (el.style.position === 'fixed' || window.getComputedStyle(el).position === 'fixed');
                 if (!isElementFixed) { // Only hide non-fixed elements with display: none
                    el.style.display = 'none';
                 } else { // For fixed elements, set display to none after fade out
                     el.style.display = 'none';
                 }
            });
            if (callback) callback(); // Execute callback if provided
        }, 500); // Match CSS transition duration for fade out
    }


    // --- Text Display Function (Smooth Fade-in) ---
    /**
     * Displays the given HTML string in the target element with a smooth fade-in animation.
     * @param {HTMLElement} element - The element to display into (e.g., resultTextAreaEl).
     * @param {string} htmlString - The HTML string to display.
     * @param {Function} onComplete - Callback function to execute after fade-in is complete.
     */
    function displayResultTextSmoothly(element, htmlString, onComplete) {
        // Fade out current content first
        element.style.opacity = 0;

        // Wait for fade-out to complete before changing content and fading in
        // The duration here should match the CSS transition duration for opacity
        const fadeOutDelay = 300; // Shorter delay for fade-out
        const fadeInDuration = 1500; // Match CSS transition duration (1.5s) for fade-in

        setTimeout(() => {
            element.innerHTML = htmlString; // Set new content instantly

            // Force a reflow/repaint to ensure the opacity: 0 is applied before opacity: 1
            // This is a common technique to make sure the transition is triggered.
            // void element.offsetWidth; // Removed as it might cause abruptness

            // Fade in new content - use a very small delay to ensure transition triggers
            setTimeout(() => {
                element.style.opacity = 1;
                 // Execute onComplete callback after the fade-in transition duration
                setTimeout(() => {
                     if (onComplete) onComplete();
                }, fadeInDuration);
            }, 50); // Small delay to allow browser to register opacity: 0 before opacity: 1

        }, fadeOutDelay); // Use the defined fade out delay
    }

    // --- Function to process result section HTML (remove numbers) ---
    /**
     * Processes a single result section HTML string to remove leading numbers (e.g., "1. ").
     * Assumes the number is at the start of the text content within the first <p> or <strong> tag.
     * @param {string} sectionHTML - The HTML string for a single result section.
     * @returns {string} The processed HTML string with leading numbers removed.
     */
    function processResultSectionHTML(sectionHTML) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = sectionHTML.trim(); // Use trim() in case there's leading/trailing whitespace

        // Find the first text node or element that might contain the number prefix
        let targetNode = null;
        if (tempDiv.firstChild) {
             // Check if the first child is a text node or an element
            if (tempDiv.firstChild.nodeType === Node.TEXT_NODE) {
                targetNode = tempDiv.firstChild;
            } else if (tempDiv.firstChild.nodeType === Node.ELEMENT_NODE) {
                // If it's an element (like <p> or <strong>), look inside it
                const firstElement = tempDiv.firstChild;
                if (firstElement.firstChild && firstElement.firstChild.nodeType === Node.TEXT_NODE) {
                    targetNode = firstElement.firstChild;
                } else if (firstElement.tagName === 'STRONG' && firstElement.firstChild && firstElement.firstChild.nodeType === Node.TEXT_NODE) {
                     targetNode = firstElement.firstChild; // Target text inside <strong>
                } else {
                    // Look for text within nested elements if necessary (simple case)
                    const textNodes = [];
                    function findTextNodes(node) {
                        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim().length > 0) {
                            textNodes.push(node);
                        }
                        for (let i = 0; i < node.childNodes.length; i++) {
                            findTextNodes(node.childNodes[i]);
                        }
                    }
                    findTextNodes(firstElement);
                    if (textNodes.length > 0) {
                        targetNode = textNodes[0]; // Take the first non-empty text node found
                    }
                }
            }
        }


        if (targetNode && targetNode.nodeType === Node.TEXT_NODE) {
            let textContent = targetNode.textContent;
            // Use regex to find and remove leading number and dot (e.g., "1. ", " 2. ")
            const numberPrefixRegex = /^\s*\d+\.\s*/;
            if (numberPrefixRegex.test(textContent)) {
                targetNode.textContent = textContent.replace(numberPrefixRegex, '');
            }
        }

        // Return the modified HTML string
        return tempDiv.innerHTML;
    }


    // --- Event Handlers and Logic Functions ---

    // Initial setup: Show title, description, and start button on load
    window.onload = () => {
        titleEl.style.display = 'block';
        descriptionEl.style.display = 'block';
        startButtonEl.style.display = 'flex'; // Fixed position, set display to flex explicitly
        setTimeout(() => {
            titleEl.classList.add('visible');
            descriptionEl.classList.add('visible');
            startButtonEl.classList.add('visible'); // Fade in the fixed start button
        }, 50); // Short delay to trigger transition
    };

    // Start the test: Hide initial screen, show emotion choice
    function chooseEmotion() {
        console.log('chooseEmotion called'); // Debugging log
        // Fade out initial screen elements
        titleEl.classList.remove('visible');
        descriptionEl.classList.remove('visible');
        startButtonEl.classList.remove('visible'); // Fade out the fixed start button

        setTimeout(() => {
            // Hide initial screen elements after fade out
            titleEl.style.display = 'none';
            descriptionEl.style.display = 'none';
            startButtonEl.style.display = 'none'; // Hide fixed button after fade out

            // Clear previous result stuff
            resultTextAreaEl.innerHTML = '';
            resultButtonsEl.classList.remove('visible'); // ê²°ê³¼ ë²„íŠ¼ ì»¨í…Œì´ë„ˆ ìˆ¨ê¹€
            resultButtonsEl.style.display = 'none'; // Hide fixed buttons
            resultEl.classList.remove('visible');
            resultEl.style.display = 'none'; // Ensure result area is hidden


            // Show emotion choice div and its buttons div
            emotionChoiceEl.style.display = 'block';
            emotionButtonsEl.style.display = 'flex'; // Fixed position, set display to flex explicitly


            // Fade in emotion choice div and its buttons div
            setTimeout(() => {
                emotionChoiceEl.classList.add('visible');
                emotionButtonsEl.classList.add('visible'); // Fade in the fixed emotion choice buttons
            }, 50); // Short delay before adding visible class

        }, 500); // Match CSS transition duration for fade out
    }

    // Emotion selected: Hide emotion choice, show first question
    function selectEmotion(emotion) {
      selectedTree = questionTree[emotion];
      currentNode = selectedTree;
      answers = []; // Reset answers for the new emotion

      // Fade out emotion choice elements
      emotionChoiceEl.classList.remove('visible');
      emotionButtonsEl.classList.remove('visible'); // Fade out the fixed emotion choice buttons

      setTimeout(() => {
          // Hide emotion choice elements after fade out
          emotionChoiceEl.style.display = 'none';
          emotionButtonsEl.style.display = 'none'; // Hide fixed buttons

          // Show question element
          questionEl.style.display = 'block';
          // Show answer buttons (fixed)
          answerButtonsEl.style.display = 'flex'; // Fixed position, set display to flex explicitly

          // Fade in question element and answer buttons
          setTimeout(() => {
               questionEl.classList.add('visible');
               answerButtonsEl.classList.add('visible'); // Fade in the fixed answer buttons
               displayQuestion(); // Set the first question text
          }, 50); // Short delay before adding visible class

      }, 500); // Wait for fade out
    }

    // Display the current question
    function displayQuestion() {
      if (currentNode && currentNode.question) {
        questionEl.innerText = currentNode.question;
        // Ensure question element is visible (it might have been faded out)
        if (!questionEl.classList.contains('visible')) {
            questionEl.style.display = 'block';
            setTimeout(() => questionEl.classList.add('visible'), 50);
        }
         // Ensure answer buttons are visible (fixed)
        if (!answerButtonsEl.classList.contains('visible')) {
            answerButtonsEl.style.display = 'flex'; // Fixed position, set display to flex explicitly
            setTimeout(() => answerButtonsEl.classList.add('visible'), 50);
        }

      } else {
        // No more questions, calculate and show the result
        calculateResult();
      }
    }

    // Handle user's answer (Yes/No)
    function handleAnswer(answer) {
      if (currentNode && currentNode[answer]) {
        answers.push(answer);
        currentNode = currentNode[answer];

        // Fade out current question and answer buttons
        questionEl.classList.remove('visible');
        answerButtonsEl.classList.remove('visible'); // Fade out answer buttons (fixed)

        setTimeout(() => {
            // Hide elements after fade out
            questionEl.style.display = 'none';
            answerButtonsEl.style.display = 'none'; // Hide fixed buttons

            // Check if there's a next question before fading in
            if (currentNode && currentNode.question) {
                 displayQuestion(); // Update text and fade in question and answer buttons
            } else {
                // No more questions, transition to result
                // Fade out questionEl (already fading out), then show resultEl
                // Answer buttons are already hidden
                fadeTransition(null, resultEl, calculateResult); // Fade in resultEl and calculate
            }
        }, 500); // Wait for fade out
      }
    }

    // Calculate and display the final result
    function calculateResult() {
      // Hide question and answer elements if they are still visible
      questionEl.classList.remove('visible');
      answerButtonsEl.classList.remove('visible'); // Ensure fixed answer buttons are hidden

      setTimeout(() => {
          questionEl.style.display = 'none';
          answerButtonsEl.style.display = 'none'; // Hide fixed buttons
      }, 500);

      // í˜„ì¬ ì„ íƒëœ ê°ì •ê³¼ ë‹µë³€ ê²½ë¡œë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
      const emotion = Object.keys(questionTree).find(key => questionTree[key] === selectedTree);
      const path = answers.join('-');

      // results_data.js íŒŒì¼ì˜ resultTexts ê°ì²´ì—ì„œ í•´ë‹¹ ê°ì •ê³¼ ê²½ë¡œì˜ ê²°ê³¼ í…ìŠ¤íŠ¸ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
      let fullResultHTML = "<p>ê²°ê³¼ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</p>"; // ê¸°ë³¸ ì˜¤ë¥˜ ë©”ì‹œì§€ (HTML í˜•ì‹)

      // resultTexts ê°ì²´ê°€ ë¡œë“œë˜ì—ˆëŠ”ì§€, ê·¸ë¦¬ê³  í•´ë‹¹ ê°ì •ê³¼ ê²½ë¡œì˜ ë°ì´í„°ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
      if (typeof resultTexts !== 'undefined' && resultTexts[emotion] && resultTexts[emotion][path]) {
          fullResultHTML = resultTexts[emotion][path];
      }

      // ê²°ê³¼ HTMLì„ <hr> íƒœê·¸ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì„¹ì…˜ìœ¼ë¡œ ë¶„í• í•©ë‹ˆë‹¤.
      // ê° ì„¹ì…˜ì˜ ì‹œì‘ ë¶€ë¶„ì— <hr>ì´ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ì²« ë²ˆì§¸ ìš”ì†ŒëŠ” ê±´ë„ˆë›°ê±°ë‚˜ ì²˜ë¦¬í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
      // ì—¬ê¸°ì„œëŠ” <hr>ë¡œ ë¶„í• í•˜ê³  ê° ì„¹ì…˜ì˜ ì•ë’¤ ê³µë°±ì„ ì œê±°í•©ë‹ˆë‹¤.
      const sections = fullResultHTML.split('<hr>').map(section => section.trim()).filter(section => section.length > 0);

      // ë¶„í• ëœ ê° ì„¹ì…˜ì—ì„œ ì•„ë¼ë¹„ì•„ ìˆ«ìë¥¼ ì œê±°í•©ë‹ˆë‹¤.
      currentResultSections = sections.map(sectionHTML => processResultSectionHTML(sectionHTML));
      currentSectionIndex = 0; // ì²« ë²ˆì§¸ ì„¹ì…˜ë¶€í„° ì‹œì‘

      // ê²°ê³¼ ì˜ì—­ì„ ë¨¼ì € ë³´ì´ê²Œ í•©ë‹ˆë‹¤.
      resultEl.style.display = 'block';
      setTimeout(() => resultEl.classList.add('visible'), 50);

      // ì²« ë²ˆì§¸ ê²°ê³¼ ì„¹ì…˜ì„ ë¶€ë“œëŸ¬ìš´ í˜ì´ë“œ ì¸ ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
      displayResultTextSmoothly(resultTextAreaEl, currentResultSections[currentSectionIndex], () => {
           // í…ìŠ¤íŠ¸ í‘œì‹œ ì™„ë£Œ í›„ ê²°ê³¼ ë²„íŠ¼ ì»¨í…Œì´ë„ˆë¥¼ ë³´ì´ê²Œ í•©ë‹ˆë‹¤.
           resultButtonsEl.style.display = 'flex'; // Fixed position, set display to flex explicitly
           setTimeout(() => resultButtonsEl.classList.add('visible'), 50); // Fade in the fixed buttons
           updateResultButtons(); // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
      });
    }

    // íŠ¹ì • ê²°ê³¼ ì„¹ì…˜ì„ í‘œì‹œí•˜ëŠ” í•¨ìˆ˜ (ë¶€ë“œëŸ¬ìš´ í˜ì´ë“œ ì¸)
    function displayResultSection(index) {
        if (index >= 0 && index < currentResultSections.length) {
            // í˜„ì¬ ì„¹ì…˜ì„ resultTextAreaElì— ë¶€ë“œëŸ¬ìš´ í˜ì´ë“œ ì¸ ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ í‘œì‹œ
            displayResultTextSmoothly(resultTextAreaEl, currentResultSections[index], () => {
                // í…ìŠ¤íŠ¸ í‘œì‹œ ì™„ë£Œ í›„ ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
                currentSectionIndex = index; // ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸ëŠ” ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„
                updateResultButtons();
            });
        }
    }

    // ê²°ê³¼ í˜ì´ì§€ë„¤ì´ì…˜ ë²„íŠ¼ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” í•¨ìˆ˜
    function updateResultButtons() {
        // ì´ì „ ë²„íŠ¼ ìƒíƒœ
        if (currentSectionIndex > 0) {
            prevButtonEl.style.display = 'inline-block';
        } else {
            prevButtonEl.style.display = 'none';
        }

        // ë‹¤ìŒ ë²„íŠ¼ ìƒíƒœ
        if (currentSectionIndex < currentResultSections.length - 1) {
            nextButtonEl.style.display = 'inline-block';
            restartButtonEl.style.display = 'none'; // ë‹¤ìŒ ë²„íŠ¼ì´ ìˆìœ¼ë©´ ì¬ì‹œì‘ ë²„íŠ¼ ìˆ¨ê¹€
        } else {
            nextButtonEl.style.display = 'none'; // ë§ˆì§€ë§‰ ì„¹ì…˜ì´ë©´ ë‹¤ìŒ ë²„íŠ¼ ìˆ¨ê¹€
            restartButtonEl.style.display = 'inline-block'; // ë§ˆì§€ë§‰ ì„¹ì…˜ì´ë©´ ì¬ì‹œì‘ ë²„íŠ¼ í‘œì‹œ
        }

        // ì¬ì‹œì‘ ë²„íŠ¼ì€ ë§ˆì§€ë§‰ ì„¹ì…˜ì—ì„œë§Œ í‘œì‹œë˜ë¯€ë¡œ ìœ„ì—ì„œ ì²˜ë¦¬
        // prevButtonê³¼ nextButtonì´ ëª¨ë‘ ìˆ¨ê²¨ì§€ë©´ (ì„¹ì…˜ì´ 1ê°œ ì´í•˜), restartButtonë§Œ ë³´ì´ê²Œ ë¨.
        if (currentResultSections.length <= 1) {
             prevButtonEl.style.display = 'none';
             nextButtonEl.style.display = 'none';
             restartButtonEl.style.display = 'inline-block';
        }
    }


    // ê²°ê³¼ í˜ì´ì§€ë„¤ì´ì…˜ íƒìƒ‰ í•¨ìˆ˜
    function navigateResult(direction) {
        const newIndex = currentSectionIndex + direction;
        displayResultSection(newIndex);
    }


    // Restart the test: Hide result, show initial screen
    function restartTest() {
        // Fade out result elements
        resultEl.classList.remove('visible');
        resultButtonsEl.classList.remove('visible'); // Fade out fixed buttons container

        setTimeout(() => {
            // Hide elements after fade out
            resultEl.style.display = 'none'; // Hide result area
            resultButtonsEl.style.display = 'none'; // Hide fixed buttons

            // Reset state variables
            selectedTree = null;
            currentNode = null;
            answers = [];
            currentResultSections = []; // ê²°ê³¼ ì„¹ì…˜ ë°°ì—´ ì´ˆê¸°í™”
            currentSectionIndex = 0; // ì¸ë±ìŠ¤ ì´ˆê¸°í™”


            // Make sure other elements are hidden
            emotionChoiceEl.style.display = 'none';
            questionEl.style.display = 'none';
            answerButtonsEl.style.display = 'none'; // Ensure fixed answer buttons are hidden
            emotionChoiceEl.classList.remove('visible');
            questionEl.classList.remove('visible');
            answerButtonsEl.classList.remove('visible');


            // Show initial screen elements (title, description, start button)
            titleEl.style.display = 'block';
            descriptionEl.style.display = 'block';
            startButtonEl.style.display = 'flex'; // Fixed position, set display to flex explicitly

             // Fade in initial screen elements
             setTimeout(() => {
                titleEl.classList.add('visible');
                descriptionEl.classList.add('visible');
                startButtonEl.classList.add('visible'); // Fade in the fixed start button
            }, 50); // Short delay before adding visible class

        }, 500); // Wait for fade out
    }

  </script>
</body>
</html>
